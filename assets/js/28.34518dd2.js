(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{506:function(t,v,_){"use strict";_.r(v);var a=_(4),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"前端缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端缓存"}},[t._v("#")]),t._v(" 前端缓存")]),t._v(" "),_("h2",{attrs:{id:"浏览器缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[t._v("#")]),t._v(" 浏览器缓存")]),t._v(" "),_("p",[t._v("浏览器中的缓存作用分为两种情况，一种是需要发送"),_("code",[t._v("HTTP")]),t._v("请求，一种是不需要发送。这两种情况分别为")]),t._v(" "),_("ul",[_("li",[t._v("强缓存")]),t._v(" "),_("li",[t._v("协议缓存")])]),t._v(" "),_("h3",{attrs:{id:"强缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),_("p",[t._v("强缓存是首先被检查的（通过字段进行检查），这个阶段不需要"),_("code",[t._v("HTTP")]),t._v("请求，并且在"),_("code",[t._v("HTTP/1.0")]),t._v("和"),_("code",[t._v("HTTP/1.1")]),t._v("当中，这个字段是不一样的。在"),_("code",[t._v("HTTP/1.0")]),t._v("时期，使用的是"),_("strong",[t._v("Expires")]),t._v("，而"),_("code",[t._v("HTTP/1.1")]),t._v("使用的是"),_("strong",[t._v("Cache-Control")])]),t._v(" "),_("h4",{attrs:{id:"expires"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[t._v("#")]),t._v(" "),_("strong",[t._v("Expires")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("Expires: Wed, 15 June 2020 02:05:00 GMT\n")])])]),_("p",[_("code",[t._v("Expires")]),t._v("即过期时间，在服务器返回的响应头中，表示在2020.06.15 02:05之前可以直接从缓存获取数据不用再次请求")]),t._v(" "),_("p",[t._v("因为浏览器的时间和服务器的时间可能不一致，导致过期时间不准确，所以在"),_("code",[t._v("http/1.1")]),t._v("中被废弃")]),t._v(" "),_("h4",{attrs:{id:"cache-control"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[t._v("#")]),t._v(" "),_("strong",[t._v("Cache-Control")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("Cache-Control:max-age=3600\n")])])]),_("p",[_("code",[t._v("Cache-Control")]),t._v("通过设置过期时长来控制缓存，字段为max-age（代码表示3600秒缓存过期）")]),t._v(" "),_("p",[_("code",[t._v("Cache-Control")]),t._v("不仅可以控制过期时间，还有很多属性")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("public")]),t._v(": 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的"),_("code",[t._v("代理服务器")]),t._v("最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。")]),t._v(" "),_("li",[_("strong",[t._v("private")]),t._v("： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。")]),t._v(" "),_("li",[_("strong",[t._v("no-cache")]),t._v(": 跳过当前的强缓存，发送HTTP请求，即直接进入"),_("code",[t._v("协商缓存阶段")]),t._v("。")]),t._v(" "),_("li",[_("strong",[t._v("no-store")]),t._v("：非常粗暴，不进行任何形式的缓存。")]),t._v(" "),_("li",[_("strong",[t._v("s-maxage")]),t._v("：这和"),_("code",[t._v("max-age")]),t._v("长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。")]),t._v(" "),_("li",[_("strong",[t._v("must-revalidate")]),t._v(": 是缓存就会有过期的时候，加上这个字段一旦缓存过期，就必须回到源服务器验证。")])]),t._v(" "),_("p",[t._v("当"),_("code",[t._v("expires")]),t._v("和"),_("code",[t._v("Cache-Control")]),t._v("同时存在的时候，优先使用"),_("code",[t._v("Cache-Control")])]),t._v(" "),_("h3",{attrs:{id:"协议缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协议缓存"}},[t._v("#")]),t._v(" 协议缓存")]),t._v(" "),_("p",[t._v("当强缓存失效了，就进入协议缓存")]),t._v(" "),_("p",[t._v("浏览器在请求头携带相应的缓存tag来向服务器发送请求，由服务器根据这个tag来决定是否使用缓存。")]),t._v(" "),_("p",[t._v("具体来说，这样的缓存tag分为两种: "),_("strong",[t._v("Last-Modified")]),t._v(" 和 "),_("strong",[t._v("ETag")]),t._v("。")]),t._v(" "),_("h4",{attrs:{id:"last-modified"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#last-modified"}},[t._v("#")]),t._v(" Last-Modified")]),t._v(" "),_("p",[t._v("Last-Modified即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。")]),t._v(" "),_("p",[t._v("浏览器接收到后，如果再次请求，会在请求头中携带"),_("code",[t._v("If-Modified-Since")]),t._v("字段，这个字段的值也就是服务器传来的最后修改时间。")]),t._v(" "),_("p",[t._v("服务器拿到请求头中的"),_("code",[t._v("If-Modified-Since")]),t._v("的字段后，其实会和这个服务器中"),_("code",[t._v("该资源的最后修改时间")]),t._v("对比:")]),t._v(" "),_("ul",[_("li",[t._v("如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。")]),t._v(" "),_("li",[t._v("否则返回304，告诉浏览器直接用缓存。")])]),t._v(" "),_("h4",{attrs:{id:"etag"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[t._v("#")]),t._v(" ETag")]),t._v(" "),_("p",[_("code",[t._v("ETag")]),t._v(" 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过"),_("code",[t._v("响应头")]),t._v("把这个值给浏览器。")]),t._v(" "),_("p",[t._v("浏览器接收到"),_("code",[t._v("ETag")]),t._v("的值，会在下次请求时，将这个值作为"),_("strong",[t._v("If-None-Match")]),t._v("这个字段的内容，并放到请求头中，然后发给服务器。")]),t._v(" "),_("p",[t._v("服务器接收到"),_("strong",[t._v("If-None-Match")]),t._v("后，会跟服务器上该资源的"),_("strong",[t._v("ETag")]),t._v("进行比对:")]),t._v(" "),_("ul",[_("li",[t._v("如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。")]),t._v(" "),_("li",[t._v("否则返回304，告诉浏览器直接用缓存。、")])]),t._v(" "),_("h4",{attrs:{id:"两者之间的差异"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#两者之间的差异"}},[t._v("#")]),t._v(" 两者之间的差异")]),t._v(" "),_("p",[t._v("在性能方面Last-Midified更好")]),t._v(" "),_("p",[t._v("在进准度方面ETag更好")]),t._v(" "),_("p",[t._v("如果两种方式都支持的话，服务器会优先考虑"),_("code",[t._v("ETag")])]),t._v(" "),_("p",[t._v("​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t（——引用借鉴"),_("RouterLink",{attrs:{to:"/src/[http://47.98.159.95/my_blog/perform/001.html#缓存位置](http://47.98.159.95/my_blog/perform/001.html#缓存位置)"}},[t._v("神三元")]),t._v(")")],1)])}),[],!1,null,null,null);v.default=e.exports}}]);